# Really Small Algorithm
### Writeup by arcayn, 150 points
`Connect to the network service to get the flag.`

Next up in the RSA challenges was this, and my first thought was that the name of this challenge was hinting that this was simulating an RSA deployment on an embedded system. A common vulnerability here is the "one-shared-prime" vulnerability, where the deployment uses bad key generation routines which tend to repeat primes. In this case, we can find two public keys with Ns `N0, N1` and compute `gcd(N0, N1)`, which allows us to trivially fully factorize both Ns. So on being confronted with:
```
n: 158533429074497257808641090644906277442789473400703923126157535057619065042376820086204054991083986524092850748319508973390733743130091002413255726088086397
e: 65537
ct: 37391789437016170546272648202285340553452810492586586960018360485066126406156799774130523850814663525173687545946467783179917872873187400036571049531972324
```
My immediate thought was to connect to the service again
```
n: 128339560508362118950146380601827582828141030605417355531407732015042529030785031563253082996807986528116485324022767979768267903132673761877489462635958321
e: 65537
ct: 113753297295641407424645932325519266130756225473162742187139805726953641328684249867147544673664254613604007908818217232153060979170229846027642351261772564
```
Sure enough, I'm given a different N, meaning the service lets me generate arbitrary public keys. Lets throw these into sage:
```python
> a = 128339560508362118950146380601827582828141030605417355531407732015042529030785031563253082996807986528116485324022767979768267903132673761877489462635958321
> b = 158533429074497257808641090644906277442789473400703923126157535057619065042376820086204054991083986524092850748319508973390733743130091002413255726088086397
> gcd(a,b)
17
```
Ah.
Well, I was technically right - there is a one-shared-prime vulnerability, except this is also just 17, so I could have factored it anyway... we live and learn. Let's solve with sage.
```python
> n = 128339560508362118950146380601827582828141030605417355531407732015042529030785031563253082996807986528116485324022767979768267903132673761877489462635958321
> p = 17
> q = n//17
> e = 65537
> phi = (p-1) * (q-1)
> d = inverse_mod(e, phi)
> ct = 113753297295641407424645932325519266130756225473162742187139805726953641328684249867147544673664254613604007908818217232153060979170229846027642351261772564
> pow(ct, d, n)
789424672162027037124394589095952276119053632356820220807985810740834941
```
Once again, converting this number to bytes gives us the flag `ractf{S0m3t1mesS1zeDoesM4773r}`.
